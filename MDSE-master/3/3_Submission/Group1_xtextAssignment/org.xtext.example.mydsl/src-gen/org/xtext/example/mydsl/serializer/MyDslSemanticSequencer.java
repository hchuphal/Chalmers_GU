/*
 * generated by Xtext 2.16.0
 */
package org.xtext.example.mydsl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import manufacturingSystem.BinaryCondition;
import manufacturingSystem.CompositeManufacturingStep;
import manufacturingSystem.InputCondition;
import manufacturingSystem.ManufacturingStep;
import manufacturingSystem.ManufacturingSystem;
import manufacturingSystem.ManufacturingSystemElement;
import manufacturingSystem.ManufacturingSystemPackage;
import manufacturingSystem.Negation;
import manufacturingSystem.OutputDecision;
import manufacturingSystem.QualityAssuranceStep;
import manufacturingSystem.Responsible;
import manufacturingSystem.StoragePoint;
import manufacturingSystem.TransportStep;
import manufacturingSystem.WorkPiece;
import manufacturingSystem.WorkPieceCondition;
import manufacturingSystem.WorkPieceType;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.mydsl.services.MyDslGrammarAccess;

@SuppressWarnings("all")
public class MyDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MyDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == ManufacturingSystemPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ManufacturingSystemPackage.BINARY_CONDITION:
				sequence_BinaryCondition(context, (BinaryCondition) semanticObject); 
				return; 
			case ManufacturingSystemPackage.COMPOSITE_MANUFACTURING_STEP:
				sequence_CompositeManufacturingStep(context, (CompositeManufacturingStep) semanticObject); 
				return; 
			case ManufacturingSystemPackage.INPUT_CONDITION:
				sequence_InputCondition_Impl(context, (InputCondition) semanticObject); 
				return; 
			case ManufacturingSystemPackage.MANUFACTURING_STEP:
				sequence_ManufacturingStep(context, (ManufacturingStep) semanticObject); 
				return; 
			case ManufacturingSystemPackage.MANUFACTURING_SYSTEM:
				sequence_ManufacturingSystem(context, (ManufacturingSystem) semanticObject); 
				return; 
			case ManufacturingSystemPackage.MANUFACTURING_SYSTEM_ELEMENT:
				sequence_ManufacturingSystemElement_Impl(context, (ManufacturingSystemElement) semanticObject); 
				return; 
			case ManufacturingSystemPackage.NEGATION:
				sequence_Negation(context, (Negation) semanticObject); 
				return; 
			case ManufacturingSystemPackage.OUTPUT_DECISION:
				sequence_OutputDecision(context, (OutputDecision) semanticObject); 
				return; 
			case ManufacturingSystemPackage.QUALITY_ASSURANCE_STEP:
				sequence_QualityAssuranceStep(context, (QualityAssuranceStep) semanticObject); 
				return; 
			case ManufacturingSystemPackage.RESPONSIBLE:
				sequence_Responsible(context, (Responsible) semanticObject); 
				return; 
			case ManufacturingSystemPackage.STORAGE_POINT:
				sequence_StoragePoint(context, (StoragePoint) semanticObject); 
				return; 
			case ManufacturingSystemPackage.TRANSPORT_STEP:
				sequence_TransportStep(context, (TransportStep) semanticObject); 
				return; 
			case ManufacturingSystemPackage.WORK_PIECE:
				sequence_WorkPiece(context, (WorkPiece) semanticObject); 
				return; 
			case ManufacturingSystemPackage.WORK_PIECE_CONDITION:
				sequence_WorkPieceCondition(context, (WorkPieceCondition) semanticObject); 
				return; 
			case ManufacturingSystemPackage.WORK_PIECE_TYPE:
				sequence_WorkPieceType(context, (WorkPieceType) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     InputCondition returns BinaryCondition
	 *     BinaryCondition returns BinaryCondition
	 *
	 * Constraint:
	 *     (name=EString left=[InputCondition|EString] type=BinaryType right=[InputCondition|EString])
	 */
	protected void sequence_BinaryCondition(ISerializationContext context, BinaryCondition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ManufacturingSystemPackage.Literals.INPUT_CONDITION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ManufacturingSystemPackage.Literals.INPUT_CONDITION__NAME));
			if (transientValues.isValueTransient(semanticObject, ManufacturingSystemPackage.Literals.BINARY_CONDITION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ManufacturingSystemPackage.Literals.BINARY_CONDITION__LEFT));
			if (transientValues.isValueTransient(semanticObject, ManufacturingSystemPackage.Literals.BINARY_CONDITION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ManufacturingSystemPackage.Literals.BINARY_CONDITION__TYPE));
			if (transientValues.isValueTransient(semanticObject, ManufacturingSystemPackage.Literals.BINARY_CONDITION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ManufacturingSystemPackage.Literals.BINARY_CONDITION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBinaryConditionAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getBinaryConditionAccess().getLeftInputConditionEStringParserRuleCall_4_0_1(), semanticObject.eGet(ManufacturingSystemPackage.Literals.BINARY_CONDITION__LEFT, false));
		feeder.accept(grammarAccess.getBinaryConditionAccess().getTypeBinaryTypeEnumRuleCall_5_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getBinaryConditionAccess().getRightInputConditionEStringParserRuleCall_7_0_1(), semanticObject.eGet(ManufacturingSystemPackage.Literals.BINARY_CONDITION__RIGHT, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ManufacturingSystemElement returns CompositeManufacturingStep
	 *     CompositeManufacturingStep returns CompositeManufacturingStep
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         speed=EInt 
	 *         (transition+=[ManufacturingSystemElement|EString] transition+=[ManufacturingSystemElement|EString]*)? 
	 *         responsible=[Responsible|EString] 
	 *         input+=InputCondition 
	 *         input+=InputCondition* 
	 *         output+=OutputDecision 
	 *         output+=OutputDecision* 
	 *         contains=ManufacturingSystem
	 *     )
	 */
	protected void sequence_CompositeManufacturingStep(ISerializationContext context, CompositeManufacturingStep semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InputCondition returns InputCondition
	 *     InputCondition_Impl returns InputCondition
	 *
	 * Constraint:
	 *     name=EString
	 */
	protected void sequence_InputCondition_Impl(ISerializationContext context, InputCondition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ManufacturingSystemPackage.Literals.INPUT_CONDITION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ManufacturingSystemPackage.Literals.INPUT_CONDITION__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInputCondition_ImplAccess().getNameEStringParserRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ManufacturingSystemElement returns ManufacturingStep
	 *     ManufacturingStep returns ManufacturingStep
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         speed=EInt 
	 *         (transition+=[ManufacturingSystemElement|EString] transition+=[ManufacturingSystemElement|EString]*)? 
	 *         responsible=[Responsible|EString] 
	 *         input+=InputCondition 
	 *         input+=InputCondition* 
	 *         output+=OutputDecision 
	 *         output+=OutputDecision*
	 *     )
	 */
	protected void sequence_ManufacturingStep(ISerializationContext context, ManufacturingStep semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ManufacturingSystemElement returns ManufacturingSystemElement
	 *     ManufacturingSystemElement_Impl returns ManufacturingSystemElement
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         (transition+=[ManufacturingSystemElement|EString] transition+=[ManufacturingSystemElement|EString]*)? 
	 *         responsible=[Responsible|EString]
	 *     )
	 */
	protected void sequence_ManufacturingSystemElement_Impl(ISerializationContext context, ManufacturingSystemElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ManufacturingSystem returns ManufacturingSystem
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         start+=[StoragePoint|EString] 
	 *         start+=[StoragePoint|EString]* 
	 *         end+=[StoragePoint|EString] 
	 *         end+=[StoragePoint|EString]* 
	 *         staff+=Responsible 
	 *         staff+=Responsible* 
	 *         responsible=[Responsible|EString] 
	 *         (uses+=WorkPieceType uses+=WorkPieceType*)? 
	 *         (transforms+=WorkPiece transforms+=WorkPiece*)? 
	 *         (consistsOf+=ManufacturingSystemElement | consistsOf+=ManufacturingSystemElement)*
	 *     )
	 */
	protected void sequence_ManufacturingSystem(ISerializationContext context, ManufacturingSystem semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InputCondition returns Negation
	 *     Negation returns Negation
	 *
	 * Constraint:
	 *     (name=EString contains=[InputCondition|EString])
	 */
	protected void sequence_Negation(ISerializationContext context, Negation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ManufacturingSystemPackage.Literals.INPUT_CONDITION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ManufacturingSystemPackage.Literals.INPUT_CONDITION__NAME));
			if (transientValues.isValueTransient(semanticObject, ManufacturingSystemPackage.Literals.NEGATION__CONTAINS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ManufacturingSystemPackage.Literals.NEGATION__CONTAINS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNegationAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getNegationAccess().getContainsInputConditionEStringParserRuleCall_6_0_1(), semanticObject.eGet(ManufacturingSystemPackage.Literals.NEGATION__CONTAINS, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OutputDecision returns OutputDecision
	 *
	 * Constraint:
	 *     (outputTypes=[WorkPieceType|EString]? input+=[InputCondition|EString] input+=[InputCondition|EString]*)
	 */
	protected void sequence_OutputDecision(ISerializationContext context, OutputDecision semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ManufacturingSystemElement returns QualityAssuranceStep
	 *     QualityAssuranceStep returns QualityAssuranceStep
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         speed=EInt 
	 *         (transition+=[ManufacturingSystemElement|EString] transition+=[ManufacturingSystemElement|EString]*)? 
	 *         responsible=[Responsible|EString] 
	 *         input+=InputCondition 
	 *         input+=InputCondition* 
	 *         output+=OutputDecision 
	 *         output+=OutputDecision*
	 *     )
	 */
	protected void sequence_QualityAssuranceStep(ISerializationContext context, QualityAssuranceStep semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Responsible returns Responsible
	 *
	 * Constraint:
	 *     name=EString
	 */
	protected void sequence_Responsible(ISerializationContext context, Responsible semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ManufacturingSystemPackage.Literals.RESPONSIBLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ManufacturingSystemPackage.Literals.RESPONSIBLE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getResponsibleAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ManufacturingSystemElement returns StoragePoint
	 *     StoragePoint returns StoragePoint
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         responsible=[Responsible|EString] 
	 *         (stores+=[WorkPieceType|EString] stores+=[WorkPieceType|EString]*)? 
	 *         (transition+=[ManufacturingSystemElement|EString] transition+=[ManufacturingSystemElement|EString]*)?
	 *     )
	 */
	protected void sequence_StoragePoint(ISerializationContext context, StoragePoint semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ManufacturingSystemElement returns TransportStep
	 *     TransportStep returns TransportStep
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         speed=EInt 
	 *         (transition+=[ManufacturingSystemElement|EString] transition+=[ManufacturingSystemElement|EString]*)? 
	 *         responsible=[Responsible|EString] 
	 *         input+=InputCondition 
	 *         input+=InputCondition* 
	 *         output+=OutputDecision 
	 *         output+=OutputDecision*
	 *     )
	 */
	protected void sequence_TransportStep(ISerializationContext context, TransportStep semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InputCondition returns WorkPieceCondition
	 *     WorkPieceCondition returns WorkPieceCondition
	 *
	 * Constraint:
	 *     (name=EString requiresType=[WorkPieceType|EString])
	 */
	protected void sequence_WorkPieceCondition(ISerializationContext context, WorkPieceCondition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ManufacturingSystemPackage.Literals.INPUT_CONDITION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ManufacturingSystemPackage.Literals.INPUT_CONDITION__NAME));
			if (transientValues.isValueTransient(semanticObject, ManufacturingSystemPackage.Literals.WORK_PIECE_CONDITION__REQUIRES_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ManufacturingSystemPackage.Literals.WORK_PIECE_CONDITION__REQUIRES_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWorkPieceConditionAccess().getNameEStringParserRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getWorkPieceConditionAccess().getRequiresTypeWorkPieceTypeEStringParserRuleCall_4_0_1(), semanticObject.eGet(ManufacturingSystemPackage.Literals.WORK_PIECE_CONDITION__REQUIRES_TYPE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     WorkPieceType returns WorkPieceType
	 *
	 * Constraint:
	 *     name=EString
	 */
	protected void sequence_WorkPieceType(ISerializationContext context, WorkPieceType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ManufacturingSystemPackage.Literals.WORK_PIECE_TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ManufacturingSystemPackage.Literals.WORK_PIECE_TYPE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWorkPieceTypeAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     WorkPiece returns WorkPiece
	 *
	 * Constraint:
	 *     hasType=[WorkPieceType|EString]
	 */
	protected void sequence_WorkPiece(ISerializationContext context, WorkPiece semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ManufacturingSystemPackage.Literals.WORK_PIECE__HAS_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ManufacturingSystemPackage.Literals.WORK_PIECE__HAS_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWorkPieceAccess().getHasTypeWorkPieceTypeEStringParserRuleCall_4_0_1(), semanticObject.eGet(ManufacturingSystemPackage.Literals.WORK_PIECE__HAS_TYPE, false));
		feeder.finish();
	}
	
	
}
